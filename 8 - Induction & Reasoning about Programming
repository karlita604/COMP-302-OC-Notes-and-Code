*** Inductive definition od a binary tree ***

    * The empty tree /Empty/ is a binary tree, of type 'a tree
    * If l : 'a tree

It might be difficult to encode rthe invariant that we have -- correspond to the restriction that 
Red-Black trees have

This is not captured in the inductive definition that we are seeing here


*** Binary Search Trees***
A binary search three t: ('a * 'a) tree is a binary tree

  * we want to insert something 
  
  
  
  How are we going to do insertion????
  
  
  let t1 = Node((9, "a"), Node((3, "pepper"), Node ((2, "salt"), Empty, Empty), Node ((5, "dog"), Node((4, "camel"), Empty
  
  
  
  
  (* insert:  'a * 'b -> ('a * 'b) tree -> ('a * 'b) tree
   
   insert (x,d) T = T'  where (x,d) has been inserted into T
   and any previous occurrences of (x,d') in T have been
   overwritten
  
*)

let rec insert (k,v) t = match t with 
  | Empty -> Node (Empty, (k,v), Empty)
  | Node (l, (k',v'), r) ->
    if k = k'   
    then Node ((k',v), l, r)
    else
      (if k<k' 
      then Node((k',v'), insert (k,v) l), r)
      else 
      Node ((k',v'), l, insert (k,v) r)
         
        
        
 let rec lookup k t = match t with
 |Empty -> None
 |Node((k',v'), l, r) -> 
   if k = k' then 
      some (v')
      else 
         (
            if k<k' then
            lookup 
            
            
            
 *****We will use induction***** 
 
 
 STEP 1 : SAY HOW  YOU ARE GOING TO PROVE THIS
 
   INDUCTION ON t
   
   Base: t = Empty
   TO SHOW: lookup x (insert(x,d) Empty) ==> Some(d)
   
   lookup x (insert (x,d) Empty)
   ==> lookup x (Node ((x,d), Empty, Empty))    by program insert
   ==> Sode d                                   by program lookup
   
   
   Step: t = Node ((y,v), l, r)
   IH1: lookup x (Node ((x,d) l) = Some(d)
   IH2: lookup x (Node ((x,d) r) = Some(d)
   
  TO SHOW: lookup x (insert(x,d) (Node ((y,v), l, r)) ==> Some(d)
  
  lookup x (insert(x,d) (Node ((y,v), l, r)) ==> Some(d)
 
 Sub-Case: y=x
 lookup x (insert(x,d) (Node ((y,v), l, r))
 ==> lookup x (Node (x,d), l, r))      by program insert
 ==> Some d                            by program lookup
 
 Sub-Case: y<x
 lookup x (insert(x,d) (Node ((y,v), l, r))
 ==> lookup (Node ((y,v), (insert (x,d) l), r)) by program insert
 ==> lookup x (insert (x,d) l)                  by program lookout
 ==> Some(d)                                    by IH1
 Sub-Case: y>x
 
 
 
 
 
 
 
 
 
 let rec lookup k t = match t with
2 | Empty -> None
3 | Node (l , (k ’ , x ) , r ) ->
4 if k = k ’ then
5 Some x
6 else
7 if k < k ’ then lookup k l else lookup k r
         
         
         
         
         
         
         
         
         
         
         
         
         
         
