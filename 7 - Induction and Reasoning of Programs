

## Inductive definition of a list##

- The empty list [] is a list of type 'a list
- If x is an element of type 'a and xs is a list of type 'a list then x::xs is a list of type 'a list
-Nothing else is a list of type 'a list

``` 
type 'a list =
| []
| (::) of 'a * 'a list
```

## How to prove properties about lists? ##







##Example: Does is compute something meaningful

**Program A**

```
let rec rev 1 = match l with
|[] -> []
| x::1 -> (rev 1) @ [x]
```
___HOW ARE WE GOING TO PROVE???___

//Correctness property :
//For all 1 length (rev 1) = length 1 <---- P 
//Base Case <---- needs to be the empty list

For all list l, length (rev 1) = length 1
NOTE: our property P (1) = length(rev1) = length 1

By induction on th list l

BASE CASE: 1 = []
length(rev []) --> length []   //by the program rev
                      
By Induction on the list l

STEP CASE: 1 = x::xs
ASSUME (IH): length(rev xs) = length xs
TO SHOW: length (rev(x::xs)) = length (x::xs)

length(rev(x::xs)) 
---> length((rev xs) @ [x]) by program rev
---> length (rev xs) + length[x] by LEMMA

LEMMA: length(l1 @ l2) = length l1 + length l2 . // try to prove this property for practice
  This is a property we would like to use, but we need to prove.
  
---> length (rev xs) + 1  // by program length
---> length (xs) + 1      // by commutativity
<--- 1 + length (xs)      // by induction hypothesis
<--- length (x::xs)       // by program length

The case analyis of your proof falls out of the 
The recipe immediately tells us what is the smaller list
Directly leads to how tp prove for alsit no matter what
  Base case
  Ind hyp
  Assume it true for a smaller list
  


length (x::xs) --> 1 + length (xs) by program length by commutativity +



# But what is equality??

-When we say length(rev 1) = legnth 1, we are not saying that these are the same program!
-We should write
"There exists v and w st length(rev 1) *down arrow* v and length 1 *down arrow* w and v = w"
-The notation e *down arrow* v ====== e evaluates to the value of v
- We will write e = e' but its an abuse of notation





---Program B ---
```
let rec rev_tr l acc = match l with
|[] -> acc
|x::xs -> rev_tr xs (x::xs)

```


HOW TO PROVE:


For all lists if you run rev l then it would be like running rev_tr l [] 

induction l

BASE CASE:
l = []
rev []
---> []

STEP CASE:
Assume that rev xs = rev_tr xs []
To show that rev (x::xs) = rev_tr (x::xs) []

